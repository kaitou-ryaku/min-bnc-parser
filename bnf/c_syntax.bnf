"TRANSLATION_UNIT           : EXTERNAL_DECLARATION EXTERNAL_DECLARATION *" "\n"
"EXTERNAL_DECLARATION       : ( FUNCTION_DEFINITION | DECLARATION )" "\n"
"FUNCTION_DEFINITION        : DECLARATION_SPECIFIER * DECLARATOR DECLARATION * COMPOUND_STATEMENT" "\n"
"DECLARATION_SPECIFIER      : ( STORAGE_CLASS_SPECIFIER | TYPE_SPECIFIER | TYPE_QUALIFIER )" "\n"
"STORAGE_CLASS_SPECIFIER    : ( auto | register | static | extern | typedef )" "\n"
"TYPE_SPECIFIER             : ( void | char | short | int | long | float | double | signed | unsigned | STRUCT_OR_UNION_SPECIFIER | ENUM_SPECIFIER | TYPEDEF_NAME )" "\n"
"STRUCT_OR_UNION_SPECIFIER  : ( STRUCT_OR_UNION identifier lbracket STRUCT_DECLARATION STRUCT_DECLARATION * rbracket | STRUCT_OR_UNION lbracket STRUCT_DECLARATION STRUCT_DECLARATION * rbracket | STRUCT_OR_UNION identifier )" "\n"
"STRUCT_OR_UNION            : ( struct | union )" "\n"
"STRUCT_DECLARATION         : SPECIFIER_QUALIFIER * STRUCT_DECLARATOR_LIST" "\n"
"SPECIFIER_QUALIFIER        : ( TYPE_SPECIFIER | TYPE_QUALIFIER )" "\n"
"STRUCT_DECLARATOR_LIST     : ( STRUCT_DECLARATOR | STRUCT_DECLARATOR_LIST comma STRUCT_DECLARATOR )" "\n"
"STRUCT_DECLARATOR          : ( DECLARATOR | DECLARATOR colon CONSTANT_EXPRESSION | colon CONSTANT_EXPRESSION )" "\n"
"DECLARATOR                 : ( @ | POINTER ) DIRECT_DECLARATOR" "\n"
"POINTER                    : star TYPE_QUALIFIER * ( @ | POINTER )" "\n"
"TYPE_QUALIFIER             : ( const | volatile )" "\n"
"DIRECT_DECLARATOR          : ( identifier | lparen DECLARATOR rparen | DIRECT_DECLARATOR lbrace ( @ | CONSTANT_EXPRESSION ) rbrace | DIRECT_DECLARATOR lparen PARAMETER_TYPE_LIST rparen | DIRECT_DECLARATOR lparen identifier * rparen )" "\n"
"CONSTANT_EXPRESSION        : CONDITIONAL_EXPRESSION" "\n"
"CONDITIONAL_EXPRESSION     : ( LOGICAL_OR_EXPRESSION | LOGICAL_OR_EXPRESSION question EXPRESSION colon CONDITIONAL_EXPRESSION )" "\n"
"LOGICAL_OR_EXPRESSION      : ( LOGICAL_AND_EXPRESSION | LOGICAL_OR_EXPRESSION pipe_pipe LOGICAL_AND_EXPRESSION )" "\n"
"LOGICAL_AND_EXPRESSION     : ( INCLUSIVE_OR_EXPRESSION | LOGICAL_AND_EXPRESSION ampasand_ampasand INCLUSIVE_OR_EXPRESSION )" "\n"
"INCLUSIVE_OR_EXPRESSION    : ( EXCLUSIVE_OR_EXPRESSION | INCLUSIVE_OR_EXPRESSION pipe EXCLUSIVE_OR_EXPRESSION )" "\n"
"EXCLUSIVE_OR_EXPRESSION    : ( AND_EXPRESSION | EXCLUSIVE_OR_EXPRESSION hat AND_EXPRESSION )" "\n"
"AND_EXPRESSION             : ( EQUALITY_EXPRESSION | AND_EXPRESSION ampasand_ampasand EQUALITY_EXPRESSION )" "\n"
"EQUALITY_EXPRESSION        : ( RELATIONAL_EXPRESSION | EQUALITY_EXPRESSION equal_equal RELATIONAL_EXPRESSION | EQUALITY_EXPRESSION exclamation_equal RELATIONAL_EXPRESSION )" "\n"
"RELATIONAL_EXPRESSION      : ( SHIFT_EXPRESSION | RELATIONAL_EXPRESSION langle SHIFT_EXPRESSION | RELATIONAL_EXPRESSION rangle SHIFT_EXPRESSION | RELATIONAL_EXPRESSION langle_equal SHIFT_EXPRESSION | RELATIONAL_EXPRESSION rangle_equal SHIFT_EXPRESSION )" "\n"
"SHIFT_EXPRESSION           : ( ADDITIVE_EXPRESSION | SHIFT_EXPRESSION langle_langle ADDITIVE_EXPRESSION | SHIFT_EXPRESSION rangle_rangle ADDITIVE_EXPRESSION )" "\n"
"ADDITIVE_EXPRESSION        : ( MULTIPLICATIVE_EXPRESSION | ADDITIVE_EXPRESSION plus MULTIPLICATIVE_EXPRESSION | ADDITIVE_EXPRESSION minus MULTIPLICATIVE_EXPRESSION )" "\n"
"MULTIPLICATIVE_EXPRESSION  : ( CAST_EXPRESSION | MULTIPLICATIVE_EXPRESSION star CAST_EXPRESSION | MULTIPLICATIVE_EXPRESSION slash CAST_EXPRESSION | MULTIPLICATIVE_EXPRESSION percent CAST_EXPRESSION )" "\n"
"CAST_EXPRESSION            : ( UNARY_EXPRESSION | lparen TYPE_NAME rparen CAST_EXPRESSION )" "\n"
"UNARY_EXPRESSION           : ( POSTFIX_EXPRESSION | plus_plus UNARY_EXPRESSION | minus_minus UNARY_EXPRESSION | UNARY_OPERATOR CAST_EXPRESSION | sizeof UNARY_EXPRESSION | sizeof TYPE_NAME )" "\n"
"POSTFIX_EXPRESSION         : ( PRIMARY_EXPRESSION | POSTFIX_EXPRESSION lbrace EXPRESSION rbrace | POSTFIX_EXPRESSION lparen ASSIGNMENT_EXPRESSION * rparen | POSTFIX_EXPRESSION dot identifier | POSTFIX_EXPRESSION minus_rangle identifier | POSTFIX_EXPRESSION plus_plus | POSTFIX_EXPRESSION minus_minus )" "\n"
"PRIMARY_EXPRESSION         : ( identifier | CONSTANT | string | lparen EXPRESSION rparen )" "\n"
"CONSTANT                   : ( integer_constant | character_constant | floating_constant | enumeration_constant )" "\n"
"EXPRESSION                 : ( ASSIGNMENT_EXPRESSION | EXPRESSION comma ASSIGNMENT_EXPRESSION )" "\n"
"ASSIGNMENT_EXPRESSION      : ( CONDITIONAL_EXPRESSION | UNARY_EXPRESSION ASSIGNMENT_OPERATOR ASSIGNMENT_EXPRESSION )" "\n"
"ASSIGNMENT_OPERATOR        : ( equal | star_equal | slash_equal | percent_equal | plus_equal | minus_equal | langle_langle_equal | rangle_rangle_equal | ampasand_equal | hat_equal | pipe_equal )" "\n"
"UNARY_OPERATOR             : ( ampasand | star | plus | minus | tilda | exclamation )" "\n"
"TYPE_NAME                  : SPECIFIER_QUALIFIER SPECIFIER_QUALIFIER * ( @ | ABSTRACT_DECLARATOR )" "\n"
"PARAMETER_TYPE_LIST        : ( PARAMETER_LIST | PARAMETER_LIST comma dot_dot_dot )" "\n"
"PARAMETER_LIST             : ( PARAMETER_DECLARATION | PARAMETER_LIST comma PARAMETER_DECLARATION )" "\n"
"PARAMETER_DECLARATION      : ( DECLARATION_SPECIFIER DECLARATION_SPECIFIER * DECLARATOR | DECLARATION_SPECIFIER DECLARATION_SPECIFIER * ABSTRACT_DECLARATOR | DECLARATION_SPECIFIER DECLARATION_SPECIFIER * )" "\n"
"ABSTRACT_DECLARATOR        : ( POINTER | POINTER DIRECT_ABSTRACT_DECLARATOR | DIRECT_ABSTRACT_DECLARATOR )" "\n"
"DIRECT_ABSTRACT_DECLARATOR : (  lparen ABSTRACT_DECLARATOR rparen | ( @ | DIRECT_ABSTRACT_DECLARATOR ) lbrace ( @ | CONSTANT_EXPRESSION ) rbrace | ( @ | DIRECT_ABSTRACT_DECLARATOR ) lparen ( @ | PARAMETER_TYPE_LIST ) rparen )" "\n"
"ENUM_SPECIFIER             : ( enum identifier lbracket ENUMERATOR_LIST rbracket | enum lbracket ENUMERATOR_LIST rbracket | enum identifier )" "\n"
"ENUMERATOR_LIST            : ( ENUMERATOR | ENUMERATOR_LIST comma ENUMERATOR )" "\n"
"ENUMERATOR                 : ( identifier | identifier equal CONSTANT_EXPRESSION )" "\n"
"TYPEDEF_NAME               : identifier" "\n"
"DECLARATION                :  DECLARATION_SPECIFIER DECLARATION_SPECIFIER * INIT_DECLARATOR * semicolon" "\n"
"INIT_DECLARATOR            : ( DECLARATOR | DECLARATOR equal INITIALIZER )" "\n"
"INITIALIZER                : ( ASSIGNMENT_EXPRESSION | lbracket INITIALIZER_LIST rbracket | lbracket INITIALIZER_LIST comma rbracket )" "\n"
"INITIALIZER_LIST           : ( INITIALIZER | INITIALIZER_LIST comma INITIALIZER )" "\n"
"COMPOUND_STATEMENT         : lbracket DECLARATION * STATEMENT * rbracket" "\n"
"STATEMENT                  : ( LABELED_STATEMENT | EXPRESSION_STATEMENT | COMPOUND_STATEMENT | SELECTION_STATEMENT | ITERATION_STATEMENT | JUMP_STATEMENT )" "\n"
"LABELED_STATEMENT          : ( identifier colon STATEMENT | case CONSTANT_EXPRESSION colon STATEMENT | default colon STATEMENT )" "\n"
"EXPRESSION_STATEMENT       : ( @ | EXPRESSION ) semicolon" "\n"
"SELECTION_STATEMENT        : ( if lparen EXPRESSION rparen STATEMENT | if lparen EXPRESSION rparen STATEMENT else STATEMENT | switch lparen EXPRESSION rparen STATEMENT )" "\n"
"ITERATION_STATEMENT        : ( while lparen EXPRESSION rparen STATEMENT | do STATEMENT while lparen EXPRESSION rparen semicolon | for lparen ( @ | EXPRESSION ) semicolon ( @ | EXPRESSION ) semicolon ( @ | EXPRESSION ) rparen STATEMENT )" "\n"
"JUMP_STATEMENT             : ( goto identifier semicolon | continue semicolon | break semicolon | return ( @ | EXPRESSION ) semicolon )" "\n"
